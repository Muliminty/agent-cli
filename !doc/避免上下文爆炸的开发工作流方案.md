# 避免上下文爆炸的开发工作流方案

## 问题背景

在使用 Claude 进行长期项目开发时，随着对话轮数增加，上下文窗口会积累大量历史信息，导致：
1. **响应速度变慢**：模型需要处理更长的上下文
2. **成本增加**：token 使用量随上下文长度增加
3. **注意力分散**：模型可能被早期不相关的信息干扰
4. **记忆混乱**：重要信息可能被淹没在历史中

## 方案选择：手动循环工作流

经过分析，我们选择**手动循环工作流**作为最佳方案，原因如下：

### ✅ 优点
1. **完全可控**：用户手动控制会话边界，避免意外丢失进度
2. **简单可靠**：不需要复杂工具或自动化脚本
3. **灵活性高**：可根据项目进度动态调整阶段粒度
4. **便于恢复**：每次会话从最新的 git commit 开始，状态清晰

### ⚠️ 局限
1. **需要人工介入**：用户需要手动关闭/开启会话
2. **略有中断感**：需要切换会话上下文

## 核心原则

### 1. 原子性任务
- 每个 Claude 会话专注于一个**独立可验证**的功能模块
- 任务完成标准：代码可编译/运行，并通过基本验证

### 2. 频繁提交
- 每完成一个重要修改就进行 git commit
- 提交信息清晰描述本次修改内容
- 保持提交历史干净，便于回滚和追踪

### 3. 状态快照
- 每个会话结束时，项目应处于**稳定可继续**的状态
- 重要状态信息（如 TODO.md 进度）必须更新并提交

### 4. 文档连续性
- 使用项目文档（如 PROGRESS.md、TODO.md）作为跨会话的记忆载体
- 每次会话开始前先阅读相关文档恢复上下文

## 详细工作流

### 阶段 1：任务规划（会话开始前）
```bash
# 查看当前进度
git log --oneline -5
cat TODO.md | head -20

# 确定本次会话目标（1-3个具体任务）
# 示例：完成 src/cli/commands/init.ts 的实现
```

### 阶段 2：开发执行（Claude 会话中）
```
用户 → Claude：
"请帮助我实现 src/cli/commands/init.ts，具体要求如下：..."

Claude → 用户：
1. 分析现有代码结构
2. 提供实现方案
3. 编写代码并解释设计思路
4. 验证代码正确性
5. 更新相关文档
```

### 阶段 3：提交与总结（会话结束前）
```bash
# 1. 添加修改的文件
git add src/cli/commands/init.ts
git add TODO.md  # 更新进度文档

# 2. 创建提交
git commit -m "$(cat <<'EOF'
feat: 实现init命令

- 实现项目初始化命令框架
- 添加交互式参数解析
- 集成配置加载器
- 更新TODO.md进度

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"

# 3. 查看提交结果
git status
git log --oneline -3
```

### 阶段 4：会话切换
1. **保存关键信息**：复制本次会话的进度总结
2. **关闭当前窗口**：结束 Claude 会话
3. **开启新会话**：在新的 Claude 窗口中继续
4. **恢复上下文**：`git pull`（如果有多人协作），查看最新提交

## 针对长效运行智能体CLI项目的具体实践

### 项目阶段划分建议

| 阶段 | 目标 | 预计会话数 | 关键产出 |
|------|------|------------|----------|
| **第一阶段** | 补全工具函数模块 | 1-2次 | file-utils.ts, prompt-utils.ts, validation.ts |
| **第二阶段** | 实现初始化命令 | 1次 | src/cli/commands/init.ts |
| **第三阶段** | 实现状态查看命令 | 1次 | src/cli/commands/status.ts |
| **第四阶段** | 创建初始化智能体 | 2-3次 | src/core/agent/initializer.ts |
| **第五阶段** | 创建编码智能体 | 2-3次 | src/core/agent/coder.ts |

### 会话边界定义标准

1. **文件边界**：每完成一个重要文件的实现
2. **功能边界**：每实现一个完整的功能特性
3. **模块边界**：每完成一个模块的集成测试
4. **时间边界**：单次会话不超过 50 条消息

### 进度文档维护

每次会话必须更新以下文档：

```markdown
# TODO.md 更新示例
## 紧急任务（下次继续时建议顺序）

1. [x] `src/cli/commands/init.ts` - 初始化命令 ✓
2. [ ] `src/cli/commands/status.ts` - 状态查看命令
3. [ ] `src/core/agent/initializer.ts` - 初始化智能体

## 最后更新
- **时间**: 2026-02-14 10:30
- **当前会话进度**: 完成init命令框架
- **下次建议**: 实现status命令
```

## 最佳实践

### 1. 任务粒度控制
- **太小**：一个函数/方法 → 不推荐，会话切换成本高
- **合适**：一个完整类/模块 → 推荐，1-2小时工作量
- **太大**：多个模块/子系统 → 避免，容易导致上下文爆炸

### 2. 提交信息规范
```
类型(范围): 简短描述

- 详细描述修改内容
- 涉及的文件列表
- 测试状态/注意事项

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

**类型说明**：
- `feat`: 新功能
- `fix`: 错误修复
- `docs`: 文档更新
- `refactor`: 重构（不改变行为）
- `test`: 测试相关

### 3. 会话开始检查清单
- [ ] 拉取最新代码：`git pull origin main`
- [ ] 查看最近提交：`git log --oneline -5`
- [ ] 阅读 TODO.md 了解当前进度
- [ ] 确认本次会话的具体目标

### 4. 会话结束检查清单
- [ ] 代码是否通过基本验证（语法检查、类型检查）
- [ ] 是否更新了相关文档（TODO.md、PROGRESS.md）
- [ ] 是否进行了 git commit
- [ ] 是否记录了下次开始的建议

## 示例工作流：实现初始化命令

### 会话 1：创建命令框架
**目标**：创建 `src/cli/commands/init.ts` 基本结构

**步骤**：
1. 分析现有 CLI 框架 (`src/cli/index.ts`)
2. 设计 init 命令的参数和选项
3. 实现命令注册和基本验证
4. 更新 TODO.md 进度

**结束操作**：
```bash
git add src/cli/commands/init.ts TODO.md
git commit -m "feat(commands): 创建init命令框架"
```

### 会话 2：完善交互逻辑
**目标**：添加交互式提示和配置生成

**开始操作**：
```bash
git log --oneline -3  # 查看上次提交
cat TODO.md | grep -A5 "紧急任务"
```

**步骤**：
1. 集成 inquirer.js 进行交互式问答
2. 实现配置文件的生成逻辑
3. 添加输入验证和错误处理
4. 更新文档和示例

## 故障恢复策略

### 场景 1：会话意外中断
```bash
# 恢复步骤
git status              # 查看未提交的修改
git diff               # 查看具体修改内容
git stash              # 暂存当前修改（如果未完成）
git stash pop          # 在新会话中恢复
```

### 场景 2：代码冲突
```bash
# 解决步骤
git pull --rebase      # 拉取最新代码并变基
# 手动解决冲突
git add .              # 标记冲突已解决
git rebase --continue  # 继续变基
```

### 场景 3：进度丢失
1. 检查 git 历史：`git log --oneline --graph`
2. 查看文档历史：`git log -p -- TODO.md`
3. 恢复到最近稳定点：`git checkout <commit-hash>`

## 工具支持脚本（可选）

### 会话启动脚本 `start-session.sh`
```bash
#!/bin/bash
echo "=== 开发会话启动 ==="
echo "1. 拉取最新代码..."
git pull origin main

echo "2. 最近提交记录..."
git log --oneline -5

echo "3. 当前任务进度..."
if [ -f "TODO.md" ]; then
  grep -A10 "## 紧急任务" TODO.md || echo "无紧急任务记录"
fi

echo "=== 准备就绪 ==="
```

### 会话结束脚本 `end-session.sh`
```bash
#!/bin/bash
echo "=== 开发会话结束 ==="

read -p "请输入提交信息: " commit_msg

echo "1. 添加修改文件..."
git add .

echo "2. 创建提交..."
git commit -m "$commit_msg

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"

echo "3. 提交结果..."
git log --oneline -3

echo "=== 会话结束，建议关闭当前窗口 ==="
```

## 常见问题解答

### Q1: 为什么不用自动化脚本实现全自动？
**A**: Claude 无法主动控制会话生命周期，且自动化可能带来风险（如意外提交、上下文丢失）。手动控制更安全可靠。

### Q2: 如何确定合适的会话边界？
**A**: 参考以下指标：
- 代码量：300-500行新增/修改
- 时间：1-2小时专注开发
- 功能完整性：一个可独立测试的功能点

### Q3: 如果忘记提交就关闭了会话怎么办？
**A**: 使用 `git reflog` 查找历史操作，通常可以恢复未提交的修改。建议养成"先提交，后关闭"的习惯。

### Q4: 多个功能相关但代码分散怎么办？
**A**: 使用"功能特性分支"：
```bash
git checkout -b feat/init-command
# 在多个会话中开发相关功能
# 完成后合并到主分支
```

### Q5: 如何保持设计一致性？
**A**: 每次会话开始时，花5分钟：
1. 回顾已有代码风格
2. 查看相关模块的设计模式
3. 确保新代码与现有架构兼容

## 总结

手动循环工作流通过**明确的任务划分**、**频繁的代码提交**和**规范的会话管理**，有效解决了上下文爆炸问题。虽然需要一定的人工介入，但换来了更好的可控性和代码质量。

对于长效运行智能体CLI项目，建议按照模块划分开发阶段，每个阶段完成后进行完整验证和提交，确保项目始终处于可继续的稳定状态。

---
**文档版本**: 1.0
**创建时间**: 2026-02-14
**适用项目**: agent-cli
**更新建议**: 根据实际使用经验定期优化工作流细节